<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-tw" lang="zh-tw">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>SETTING INTERFACE</title>
<base href="<?%BaseDir?>"/>
<style type="text/css">@import url(stg.css);</style>

</head>
<body>



<script>
var old_XText= new Object; //for checked modify-flag
var stg_config = new Array;
var changed_flag=false;
var final_err_report_str=new String(); //from final validation
//function settings
var pass_validation =false;
var STG_TIMESTAMP=0;
var STG_REDUNDANCY=0;
var STG_STORAGE_MEMORY=0;
//validation settings(#define)
var STG_RAM_ARRAY_SIZE=0;
var STG_MAX_NUM_SETTINGS=0;
var STG_MAX_SETTING_NAME_LEN=0;
var STG_MAX_SETTING_VALUE_LEN=0;
//Report of setting number
var NUMBER_OF_SETTINGS=0;
var non_volatile_size=1;
var volatile_size=0;
//return alias
var field={storage:0,data_type:1};
var def_stg={STG_RAM_ARRAY_SIZE:0,STG_MAX_NUM_SETTINGS:1,STG_MAX_SETTING_NAME_LEN:0,STG_MAX_SETTING_VALUE_LEN:0}; //for generate setting definition for 'include'.




//summary report
function show_summary_report(ok_flag)
{
	var summary_str=new String;
	var table =document.getElementById("my_table");
  var rows = Number(table.rows.length)-1;

	summary_str="";
	var STG_MAX_NUM_SETTINGS=rows                //external.XText.length;//document.getElementById("my_table").rows.length-1;
	if (ok_flag)
	{
		summary_str='<p>Number of settings:&nbsp;&nbsp;'+STG_MAX_NUM_SETTINGS+'</p>';
		summary_str+='<p>Non-volatile memory space required:&nbsp;&nbsp;'+non_volatile_size+'</p>';
		summary_str+='<p>RAM(volatile memory)space required:&nbsp;&nbsp;'+STG_RAM_ARRAY_SIZE+'</p>';
	}
	else
	{
		summary_str='<p>Setting definitions contain invalid data and the report cannot be generated.</p>';	
		if (final_err_report_str!='') summary_str+=final_err_report_str
	}
	if (get_eof_index()==0) summary_str='<p>Definition table is empty, can\'t generate report.</p>';
	document.getElementById('summary_report').innerHTML=summary_str;
}
//show validation status
function show_err_mark(err_array)
{
	if (!err_array) return;
	for (i = 0; i < err_array.length; i++)
	{
		var Row=document.getElementById("my_table").rows[i+1]
		if (!err_array[i])
		{
			Row.cells(9).innerHTML = '<font color=\'red\'><b>INVALID</b></font>';
		}
		else
		{
			Row.cells(9).innerHTML = '<font color=\'green\'><b>OK</b></font>';
		}
	}
}

//point on first record
function point_on_first()
{
	var table =document.getElementById("my_table");
	var rows = Number(table.rows.length)-1;
	if (rows!=0) 
	{
		var Row=table.rows[1]
		Select(Row);
	}
}

//Process the timing of saving the doc if context(XTXT Object) of the doc has changed. --------------
//for compare
function compare_objects(obj1, obj2)
{
    var parameter_name;
    var compare = function(objA, objB, param){
        var param_objA = objA[param],
            param_objB = (typeof objB[param] === "undefined") ? false : objB[param];
 
        switch(typeof objA[param]){
            case "object": return (compare_objects(param_objA, param_objB));
            case "function": return (param_objA.toString() === param_objB.toString());
            default: return (param_objA === param_objB);
        }
 
    };
    for(parameter_name in obj1){
        if(typeof obj2[parameter_name] === "undefined" || !compare(obj1, obj2, parameter_name)){
        		//alert(parameter_name+','+obj2[parameter_name]+',');
            return false;
        }
    }
    
    for(parameter_name in obj2){
        if(typeof obj1[parameter_name] === "undefined" || !compare(obj1, obj2, parameter_name)){
        		
            return false;
        }        
    }
    return true;
}


var clone_object = function (original_obj) {
    var new_obj = {};
    for(var param in original_obj) {
        if(original_obj.hasOwnProperty(param)){
            if(typeof(original_obj[param]) === "object"){
                new_obj[param] = clone_object(original_obj[param]);
            } else {
                new_obj[param] = original_obj[param];
            }
        }
    }
    return new_obj;
};
   

function duplicate_xtext(result) 
{
	var obj=new Object;
	var result=new Array;
	var i=0;
	for (i = 0; i < external.XText.length; i++)
	{
		var obj=clone_object(external.XText[i]);
		result.push(obj);
	}
	return result;
}

function chk_if_changed()
{
	var i=0;
	var new_XText=external.XText;
	
	if (new_XText.length!=old_XText.length)
	return false;
	
	//alert('in_old');
	for (i = 0; i < external.XText.length; i++)
	{
				if (compare_objects(new_XText[i],old_XText[i])==false)
				return false;
	}
	return true;
}

function set_content_modify() //check if changed, if true set modify
{
	if ((chk_if_changed()==true)&&(changed_flag==false)) //add changed_flag minimize the loading, cuz can only check once(only the beginning)(cuz we can't know when it will be saved therefor unable to compare).
	{
		//alert('the same');
	}
	else
	{
		//alert('not the same');
		external.SetModified(true);
		changed_flag=true;
	}
}

var old_XText=duplicate_xtext(); //for checking changes


//get def_setting at beginning
function show_config()
{
  var obj=document.getElementsByName("checkbox");//get chk array
  var fd_file_name=document.getElementById("fd_filename");
  var chk_mem=document.getElementsByName("mem_type");
  //document.getElementByID("fd_file_div").style.visibility="hidden";
  //fd_file_div.style.display="none";
  
		for (i = 0; i < external.XText.length; i++) 
		{ 
			if (typeof(external.XText[i].CONFIG)!='undefined') //get define setting(functional settings)
			{
				//STG lib has the default value (i.e.#define STG_DEBUG_PRINT 0),
				//therefore we take a "not" defval as the symbol of enabled function. 
	
				var def_value=external.XText[i].CONFIG.replace(/^\s+|\s+$/g,""); //trim
				if (def_value=="#define STG_DEBUG_PRINT 1") {obj[0].checked = true;}
				if (def_value=="#define STG_TIMESTAMP 1") {obj[1].checked = true;STG_TIMESTAMP=1;}
				if (def_value=="#define STG_REDUNDANCY 1") {obj[2].checked = true;STG_REDUNDANCY=1;}
				if (def_value=="#define STG_STORAGE_MEMORY 1") 
				{
							chk_mem[1].checked = true;
							fd_file_name.disabled = false;
							STG_STORAGE_MEMORY=1;
							//fd_file_div.style.display="block";
							
				}
				if (def_value.indexOf("define STG_FILENAME")==1) {fd_file_name.value=def_value.slice(22,def_value.length-1);}
				
			}
		}
	//reload_config(); //reload_config()here is to init STG_DESCRIPTOR_FILE etc. but no need any more,cuz validat_all is excute at beginning
}

function ret_alias(which_field,src_str) //retrieve alias 
{
		var src=src_str.replace(/^\s+|\s+$/g,"");
		switch (which_field) 
		{
		case field.storage:
			switch(src)
			{
				case "E":
					return 'Non-volatile&nbsp;';
				case "R":
					return 'Volatile';
				default:
					return src;
			}
			break;		
		case field.data_type:
			switch(src)
			{
				case "B":
					return 'Byte';
				case "W":
					return 'Word';
				case "S":
					return 'String';
				case "D":
					return 'Dot-decimal&nbsp;';
				default:
					return src;
			}
			break;
		default: 
			return src;
			break;
		}
}

//EOF   function-------
function get_eof_index()
{
		//get index of the end of the setting(not define_data_list)
		// xtext is sorted in the beginning, therefore the first found would be the eof of the setting.
		var i=0;
		for (i = 0; i < external.XText.length; i++) 
		{ 
			if (typeof(external.XText[i].CONFIG)!='undefined') 
			{
				return i;
			}
		}
		//return (external.XText.length);
		return i;
}

//clear all config-------
function clear_all_config()
{
		// xtext is sorted in the beginning, therefore the first found would be the eof of the setting.
		var start_pos=get_eof_index();
		external.XText.splice(start_pos, Number(external.XText.length));
		//external.SetModified(true); //fff 
}

//corrupted data check(must before validation)
function chk_corrupt()
{
		for (i = 0; i < external.XText.length; i++) 
		{ 
			if (typeof(external.XText[i].CONFIG)=='undefined') //get each setting record
			{
					//STG lib has the default value (i.e.#define STG_DEBUG_PRINT 0),
					//therefore we take a "not" defval as the symbol of enabled function. 
					
					
					var stg_record=external.XText[i];                //.replace(/^\s+|\s+$/g,""); //trim continue; \r\n
					var err_report='';
					var f=0
					var count=0;
					for (var Property in stg_record)	
					{		
						f++;	
						//var field_value = stg_record[Property];					
					}
					
					//alert(f);
					if (f<8)
					{
							confirm('Setting \"'+external.XText[i].NAME+'\" descriptor has missing fields. The descriptor will be repaired using default field values.');
							external.XText[i].NAME = external.XText[i].NAME.replace(/^\s+|\s+$/g,"");
							external.XText[i].STORAGE = "E";
							external.XText[i].TYPE = "B";
							external.XText[i].MEMBER= "1";
							external.XText[i].P1="0";
							external.XText[i].P2="255";
							external.XText[i].INI= "A";
							external.XText[i].DEFVAL="0";	
							//external.XText[i].C="Restore";	
							external.SetModified(true); //fff
					}
					var Row=document.getElementById("my_table").rows[i+1]
					Row.cells(0).innerHTML = external.XText[i].NAME;
					Row.cells(1).innerHTML = ret_alias(field.storage,external.XText[i].STORAGE);
					Row.cells(2).innerHTML = ret_alias(field.data_type,external.XText[i].TYPE);
					Row.cells(3).innerHTML = external.XText[i].MEMBER;
					Row.cells(4).innerHTML = external.XText[i].P1;
					Row.cells(5).innerHTML = external.XText[i].P2;
					Row.cells(6).innerHTML = external.XText[i].INI;
					Row.cells(7).innerHTML = external.XText[i].DEFVAL;
					Row.cells(8).innerHTML = external.XText[i].C+'&nbsp';
			}
		}
}

//get settings count
function get_setting_count()
{
	var count=0;
	for (i = 0; i < external.XText.length; i++) 
	{
		if (typeof(external.XText[i].CONFIG)=='undefined') //get each setting record
		{
			count++;
		}
	}
	return count;
}

//validate single
function validate_single(obj)
{
//NAME
		if (!obj.NAME)  return false;
    if(obj.NAME!=obj.NAME.replace(/(^[0-9]*)/g, ""))  return false; //means the value start with a digit    
    if ((obj.NAME.length<1)||(obj.NAME.length>254))		return false; 
		if(STG_MAX_SETTING_NAME_LEN<obj.NAME.length)  STG_MAX_SETTING_NAME_LEN=obj.NAME.length; //only save the largest number //@@
		
//storage type
		if (!obj.STORAGE)  return false;
		if ((obj.STORAGE.length != 1)||((obj.STORAGE != 'E')&&(obj.STORAGE != 'R'))) return false;  
		
//setting type
		obj.TYPE=obj.TYPE.replace(/^\s+|\s+$/g,"");
		if (!obj.TYPE)  return false;
		if (obj.TYPE.length != 1)
		{ 
			return false; 
		}
		else
		{
					switch(obj.TYPE)
					{
					case "B":
					case "W":
					case "S":
					case "D":
					break;
					default:
					return false; 
					}
		}
		
//number of member(s)
		if (!obj.MEMBER)  return false;
		if (isNaN(obj.MEMBER)==true) return false; 			//The stg_lib will take non-numeric number as zero, but we still need to check here.
		if ((obj.MEMBER.length<1)||(obj.MEMBER.length>254))		return false; 
		
//p1, maybe add something later.
		
		if (!obj.P1)  return false;
		if ((obj.P1.length<1)||(obj.P1.length>254))		return false; 
		if (isNaN(obj.P1)==true) return false; 					//The stg_lib will take non-numeric p1 as zero, but we still need to check here.
				var data_type=obj.TYPE;
				
				switch(data_type)
				{
				case "B":
				    if (obj.P1>255) 		return false;		
						break;
				case "W"	:
				    if (obj.P1>65535)		return false;
						break;
				case "S":
				    if (obj.P1>254) 		return false;		
						break;
				case "D"	:
				    if (obj.P1>254)     return false;		
						break;					
				}		
				
//p2
		if (!obj.P2)  return false;
		if ((obj.P2.length<1)||(obj.P2.length>254))		return false; 
		if (isNaN(obj.P2)==true) return false; //The stg_lib will take non-numeric p2 as zero, but we still need to check here.
				var data_type=obj.TYPE;
				switch(data_type)
				{
				case "B":
				    if (obj.P2>255) 		return false;		
						break;
				case "W"	:
				    if (obj.P2>65535)		return false;
						break;
				case "S":
				    if (obj.P2>254) 		return false;		
						break;
				case "D"	:
				    if (obj.P2>254)     return false;		
						break;					
				}				
				var P1_value=Number(obj.P1);// what the.....
				
		    if (Number(obj.P2)<P1_value)    return false;

//calculate how much space this setting will need in memory
//validate the string value length?
		var byte_size=0;  				//j, real_size according to the definition.
		var required_str_len=0 		//len_of_str_rep,  string length required to represent setting value
		
		switch(data_type)
		{
			case "B":
				byte_size=1;
				required_str_len=3
				break;
			case "W":
				byte_size=2;
				required_str_len=5
				break;
			case "S":
				byte_size=Number(obj.P2)+1;
				required_str_len=Number(obj.P2)
				break;
			case "D":
				byte_size=Number(obj.P2)+1;
				required_str_len=Number(obj.P2)*4;
				if (required_str_len>0) 
				required_str_len=required_str_len-1;	
				break;
			default:
				return false;
		}
		
		if (STG_TIMESTAMP==1)
		{
				if ((required_str_len<1)||(required_str_len>246))  {return false;}
		}
		else
		{
				if ((required_str_len<1)||(required_str_len>253))  {return false;}
		}
		
		if(STG_MAX_SETTING_VALUE_LEN<required_str_len) STG_MAX_SETTING_VALUE_LEN=required_str_len; //@@ get max value
		byte_size=byte_size*Number(obj.MEMBER)+1; //total declare size of the current definition.(byte) 
		//alert(obj.NAME+','+byte_size);
		if (STG_TIMESTAMP==1){byte_size+=7;}           //STG_TIMESTAMP_LENGTH=7
		
		
		
		if (byte_size>255) {return false;}               //the declared size of each setting can't exceed 255byte //@@
		
		
		if (obj.STORAGE == 'E')
		{
			non_volatile_size+=byte_size         //nvmem_offset_ctr    //@@
			//alert(non_volatile_size);
		}
		else
		{
			STG_RAM_ARRAY_SIZE+=byte_size        //ramarr_offset_ctr	 //@@
		}
		
		
		
//ini mode
		if (!obj.INI)  return false;
		if ((obj.INI.length != 1)||((obj.INI != 'I')&&(obj.INI != 'A'))) return false; 

//default value

		if (!obj.DEFVAL)  return false;
		var defval_array=obj.DEFVAL.split("/");
		var extract_def_value=0;
		for (var k=0;k<defval_array.length;k++)
		{
					switch(data_type)
					{
						case "B":
						case "W":
							extract_def_value=Number(defval_array[k]);
							if (defval_array[k]=="^") extract_def_value=0;
							if (isNaN(extract_def_value)==true) {return false;} //alert('NaN');  //this validation condition won't be checked by stg_lib, but we still check here.
							if (extract_def_value<obj.P1) return false;
							if (extract_def_value>obj.P2) return false;
							break;
						case "S":
							extract_def_value=defval_array[k].length;
							if (defval_array[k]=="^") extract_def_value=0;
							if (extract_def_value<obj.P1) return false;
							if (extract_def_value>obj.P2) return false;											
							break;
						case "D":
							var tmp_D=defval_array[k].split(".");
							extract_def_value=tmp_D.length;
							if (defval_array[k]=="^") extract_def_value=0;	
							if (extract_def_value<obj.P1) return false;
							if (extract_def_value>obj.P2) return false;									
							break;
						default:
							break;
					}
		}
		
		return true;
}

//validate all validation settings
function validate_all()
{
		//pre_process (Because of chk_corrupt, we don't have to check null field again.)
		NUMBER_OF_SETTINGS=get_setting_count();
		var err_mark_list = new Array();
		var all_ok=true;
		non_volatile_size=1; //init value for summary report
		STG_RAM_ARRAY_SIZE=0;
		STG_MAX_NUM_SETTINGS=document.getElementById("my_table").rows.length-1;
		
		//validate start
		for (i = 0; i < external.XText.length; i++) 
		{
			if (typeof(external.XText[i].CONFIG)=='undefined') //get each setting record
			{
					var tmp=external.XText[i];
					if ((validate_single(tmp))==false)
					{
						all_ok=false;
						err_mark_list.push(false)
					}
					else
					{
						err_mark_list.push(true)
					}
			}
		}
		
		if (STG_REDUNDANCY==1){non_volatile_size*=2;} //if (STG_REDUNDANCY==1){byte_size*=2;}
		show_err_mark(err_mark_list);
		//----final validation---
							final_err_report_str=''
							if (STG_MAX_NUM_SETTINGS>255) 		{alert('Max settings count can\'t > 255');final_err_report_str='# Max settings count can\'t > 255, you have '+STG_MAX_NUM_SETTINGS+'.';all_ok=false;}
							//if (STG_MAX_SETTING_NAME_LEN>255) {alert('Max length of the longest setting\'s name can\'t > 255');all_ok=false;}
							if (STG_TIMESTAMP==1)
							{
									//already validated in validate_single//if ((STG_MAX_SETTING_VALUE_LEN<1)||(STG_MAX_SETTING_VALUE_LEN>246))  {all_ok=false;}
							}
							else
							{
									//already validated in validate_single//if ((STG_MAX_SETTING_VALUE_LEN<1)||(STG_MAX_SETTING_VALUE_LEN>253))  {all_ok=false;}
							}
		//------------------------
		show_summary_report(all_ok);
		
		

		
		
		if (all_ok)
		{
			def_stg.STG_RAM_ARRAY_SIZE=STG_RAM_ARRAY_SIZE;
			def_stg.STG_MAX_SETTING_NAME_LEN=STG_MAX_SETTING_NAME_LEN;
			def_stg.STG_MAX_SETTING_VALUE_LEN=STG_MAX_SETTING_VALUE_LEN;					
		}
		else
		{
			def_stg.STG_RAM_ARRAY_SIZE=0;
			def_stg.STG_MAX_SETTING_NAME_LEN=0;
			def_stg.STG_MAX_SETTING_VALUE_LEN=0;				
		}
		def_stg.STG_MAX_NUM_SETTINGS=STG_MAX_NUM_SETTINGS;

		reload_config();
		return all_ok;
}

//reload all config------
function reload_config()
{
	
  var chk_obj=document.getElementsByName("checkbox");//get chk array
  var chk_mem=document.getElementsByName("mem_type");// get radio array
  var fd_file_name=document.getElementById("fd_filename");//get filename
  
	var Obj = new Object;
		
	clear_all_config();
	//always add descriptor_file_name
	Obj.CONFIG = "#define STG_DESCRIPTOR_FILE \""+external.FileName+"\""; 
	external.XText.push(Obj);
	
	var Obj = new Object;
	
	
	//1.function settings
		if (chk_obj[0].checked == true)
		{	
	 		Obj.CONFIG = "#define STG_DEBUG_PRINT 1";
	 		external.XText.push(Obj);
		}
		var Obj = new Object; 
		if (chk_obj[1].checked == true)
		{
	 		Obj.CONFIG = "#define STG_TIMESTAMP 1";
	 		external.XText.push(Obj);
	 		STG_TIMESTAMP=1;
		}else{STG_TIMESTAMP=0;}
		var Obj = new Object;
		if (chk_obj[2].checked == true)
		{
	 		Obj.CONFIG = "#define STG_REDUNDANCY 1";
	 		external.XText.push(Obj);
	 		STG_REDUNDANCY=1;
		}else{STG_REDUNDANCY=0;}
		
		var Obj = new Object;
		if (chk_mem[1].checked == true)
		{
	 		Obj.CONFIG = "#define STG_STORAGE_MEMORY 1";
	 		external.XText.push(Obj);
	 		STG_STORAGE_MEMORY=1;
	 		
	 		var Obj = new Object;
	 		Obj.CONFIG = '#define STG_FILENAME \"'+fd_file_name.value+'\"';
	 		external.XText.push(Obj);
	 		fd_file_name.disabled = false;
	 		fd_file_div.style.color='black';fd_file_name.style.backgroundColor='white';
	 		//fd_file_div.style.display="block";
	 		
	 		
		}else{STG_STORAGE_MEMORY=0;fd_file_name.disabled = true;fd_file_div.style.color='gray';fd_file_name.style.backgroundColor='#F2F2F2'; }//fd_file_div.style.display="none";
		
		
		
	//2.Validation settings(validation result)
		var Obj = new Object;
		Obj.CONFIG = "#define STG_MAX_NUM_SETTINGS "+def_stg.STG_MAX_NUM_SETTINGS;
	 	external.XText.push(Obj);
	 	
		var Obj = new Object;
		Obj.CONFIG = "#define STG_RAM_ARRAY_SIZE "+def_stg.STG_RAM_ARRAY_SIZE;
	 	external.XText.push(Obj);
	 	
		var Obj = new Object;
		Obj.CONFIG = "#define STG_MAX_SETTING_NAME_LEN "+def_stg.STG_MAX_SETTING_NAME_LEN;
	 	external.XText.push(Obj);
	 	
		var Obj = new Object;
		Obj.CONFIG = "#define STG_MAX_SETTING_VALUE_LEN "+def_stg.STG_MAX_SETTING_VALUE_LEN;
	 	external.XText.push(Obj);
	 	
	 
		set_content_modify();//external.SetModified(true); //fff
}

//other---------------
var SelectedRow;

function Select(Row)
{
	if (SelectedRow)
		SelectedRow.bgColor = 0xffffff;
	
	Row.bgColor = 0xff9080;
	SelectedRow = Row;
}

function Delete(Row)
{	
	if (!Row)
		return;
		
	if (Row == SelectedRow)
		SelectedRow = null;
	
	external.XText.splice(Row.rowIndex-1, 1);
	external.SetModified(true);

	document.getElementById('my_table').deleteRow(Row.rowIndex);
	validate_all();
}

function Edit(Row)
{	
	if (!Row)
		return;
	
	var Context = new Object;
	Context.Target = external.XText[Row.rowIndex-1];
	Context.TIMESTAMP = STG_TIMESTAMP;
	Context.REDUNDANCY = STG_REDUNDANCY;
	
	var Result = external.ModalDialog("stg_edit.html", "Edit Setting Item", Context);
	if (Result != 1)
		return;	
	
	Row.cells(0).innerHTML = Context.Target.NAME;	
	Row.cells(1).innerHTML = ret_alias(field.storage,Context.Target.STORAGE);
	Row.cells(2).innerHTML = ret_alias(field.data_type,Context.Target.TYPE);
	Row.cells(3).innerHTML = Context.Target.MEMBER;
	Row.cells(4).innerHTML = Context.Target.P1;
	Row.cells(5).innerHTML = Context.Target.P2;
	Row.cells(6).innerHTML = Context.Target.INI;
	Row.cells(7).innerHTML = Context.Target.DEFVAL;
	Row.cells(8).innerHTML = Context.Target.C+'&nbsp'; //let the cell have outter frame. Only comment field can be null.
	
	
	
	external.SetModified(true);
	validate_all();
}

function Add()
{	
	var Context = new Object;
	Context.Target =new Object;
	Context.TIMESTAMP = STG_TIMESTAMP;
	Context.REDUNDANCY = STG_REDUNDANCY;
	var Obj = new Object;
	// initial value of ADD dialog box(caution: note that must be by order)
	Context.Target.NAME = "";
	Context.Target.STORAGE = "E";
	Context.Target.TYPE = "B";
	Context.Target.MEMBER= "1";
	Context.Target.P1="0";
	Context.Target.P2="";
	Context.Target.INI= "A";
	Context.Target.DEFVAL="^";	
	Context.Target.C="";	

	var Result = external.ModalDialog("stg_edit.html", "Add New Setting", Context);
	if (Result != 1)
		return;	
	

	var eof=get_eof_index();
	
	
	
	external.XText.splice(eof,0,Context.Target);    //insert new record behind the setting records.(but before the "#define...." list.)
	external.SetModified(true);
	
	
	//external.XText.push(Obj);
	//document.write('<a href="javascript:location.reload(true)">');
	var Row = document.getElementById("my_table").insertRow();
	
	Row.onmousedown = function() { Select(Row); };
	Row.ondblclick = function() { Edit(Row); };
	Row.insertCell(0).innerHTML = Context.Target.NAME;
	Row.insertCell(1).innerHTML = ret_alias(field.storage,Context.Target.STORAGE);
	Row.insertCell(2).innerHTML = ret_alias(field.data_type,Context.Target.TYPE);
	Row.insertCell(3).innerHTML = Context.Target.MEMBER;
	Row.insertCell(4).innerHTML = Context.Target.P1;
	Row.insertCell(5).innerHTML = Context.Target.P2;
	Row.insertCell(6).innerHTML = Context.Target.INI;
	Row.insertCell(7).innerHTML = Context.Target.DEFVAL;
	Row.insertCell(8).innerHTML = Context.Target.C+'&nbsp';
	Row.insertCell(9).innerHTML = '&nbsp;'; //must add this (status)
	Row.cells(9).style.backgroundColor="#F2F2F2";
	Select(Row); 

	validate_all();
}

</script>




<!-- ===============================================================HTML BODY================================================================================================ -->
<!-- ---------------------------------------------------------------HTML BODY------------------------------------------------------------------------------------------------ -->
<!-- ---------------------------------------------------------------HTML BODY------------------------------------------------------------------------------------------------ -->



<div class="posttext">
		<img class="imgleft" src="tdoc.ico" width="30" height="32"  /></img>
		<h2>Library Options (mouse over for hint)</h2>
		<div id="related_stg">
					<p><input type="checkbox" name="checkbox" id="checkbox" value="checkbox" onclick ="reload_config();validate_all();">  
					<span title="header=[<img src='info.ico' width='20' height='20'></img>        Debug Printing] body=[When checked, causes debug information to be printed into the output pane. Debug printing only works when the project is in the debug mode. However, still uncheck this option for release, as this will save memory and code space.]">
					Debug Printing</span>&nbsp;&nbsp;</p>
					

	  			<p><input type="radio"  name="mem_type" onclick ="reload_config();validate_all();" value="EEPROM" checked>
	  			<span title="header=[<img src='info.ico' width='20' height='20'></img>        Use EEPROM] body=[Non-volatile settings will be stored in the EEPROM.]">
	  			Use EEPROM </span>
	  			
	  			<input type="radio"  name="mem_type" onclick ="reload_config();validate_all();" value="FD" > 
	  			<span title="header=[<img src='info.ico' width='20' height='20'></img>        Use Flash Disk] body=[Non-volatile settings will be stored in the file on the flash disk.]">
	  			Use Flash Disk</span> </p>
	  			
          	<div id="fd_file_div">
          			<p><span title="header=[<img src='info.ico' width='20' height='20'></img>        Filename] body=[If you opt for storing non-volatile settings on the flash disk, then you can specify the filename for the file that will store settings data. Leave empty to use the default filename ('settings.dat').]">
          			Filename:</span>
          			<input type="text" ID="fd_filename"  onBlur ="reload_config();validate_all();"  maxlength="20" value=""/></p>
						</div>
					
					
					
	  			<p><input type="checkbox" name="checkbox" id="checkbox" value="checkbox" onclick ="reload_config();validate_all();">  
	  			<span title="header=[<img src='info.ico' width='20' height='20'></img>        Timestamp] body=[When checked, enables saving of date and time of the most recent value modification for each setting (one timestamp applies to all setting members).]">
	  			Timestamp</span>&nbsp;&nbsp;</p>
	  			<p><input type="checkbox" name="checkbox" id="checkbox" value="checkbox" onclick ="reload_config();validate_all();">  
	  			<span title="header=[<img src='info.ico' width='20' height='20'></img>        Redundancy] body=[When checked, enables two independent copies of setting data to be stored for improved reliability. Enabling this option doubles required non-volatile memory space.]">
	  			Redundancy</span>&nbsp;&nbsp;</p>
	  			
	  			

          
	  			<script>show_config();</script>
	  			
	  			

	  			
		</div>
</div>




<div class="posttext">
		<img class="imgleft" src="tdoc.ico" width="30" height="32" /></img>
		<h2>Setting Definitions</h2> 

		<p>
		<button style="WIDTH: 80px; HEIGHT: 25px" style="display:none;" onclick = "point_on_first();set_content_modify();">test</button>&nbsp;
		<button style="WIDTH: 80px; HEIGHT: 25px" onclick = "Add()">Add</button>&nbsp;
		<button style="WIDTH: 80px; HEIGHT: 25px" onclick = "Edit(SelectedRow)">Edit</button>&nbsp;
		<button style="WIDTH: 80px; HEIGHT: 25px " onclick = "Delete(SelectedRow)">Delete</button>&nbsp;&nbsp;&nbsp;
		</p>
		<p>
						<table border="1"  id ="my_table">
						<tr style="background-color:#FFFFFF">
						<th>Name</th>
						<th>Storage</th>
						<th>Data type</th>
						<th>Member(s)</th>
						<th>P1(min)</th>
						<th>P2(max)</th>
						<th>Ini mode </th>
						<th>Default value</th>
						<th>Comment</th>
						<th bgcolor=#F2F2F2>Status</th>
						</tr>

						
						<?
						for (i = 0; i < external.XText.length; i++) 
						{ 
							if (typeof(external.XText[i].CONFIG)=='undefined') //do not show #define setting
							{
								var Obj = external.XText[i];
								if (typeof(Obj.C)=='undefined') Obj.C=''; //prevent comment field show 'undefined' on first load
						?>
						
						<tr onmousedown = "Select(this)"  ondblclick = "Edit(this)">
						
						<td> <?%Obj.NAME?> </td>
						<td> <script>document.write(ret_alias(field.storage,'<?%Obj.STORAGE?>'));</script> </td>      <! - <?%Obj.STORAGE?> ->
						<td> <script>document.write(ret_alias(field.data_type,'<?%Obj.TYPE?>'));</script> </td>  		 <! - <?%Obj.TYPE?> ->
						<td> <?%Obj.MEMBER?> </td>
						<td> <?%Obj.P1?> </td>
						<td> <?%Obj.P2?> </td>
						<td> <?%Obj.INI?> </td>
						<td> <?%Obj.DEFVAL?> </td>
						<td><?%Obj.C?> </td>
						<td bgcolor=#F2F2F2>&nbsp</td>
						</tr>
						
						<?}}?>
						
						</table>
		</p>
		<p>
		<button style="WIDTH: 80px; HEIGHT: 25px" onclick = "Add()">Add</button>&nbsp;
		<button style="WIDTH: 80px; HEIGHT: 25px" onclick = "Edit(SelectedRow)">Edit</button>&nbsp;
		<button style="WIDTH: 80px; HEIGHT: 25px" onclick = "Delete(SelectedRow)">Delete</button>&nbsp;
		</p>
</div>

				

<div class="posttext">
<img class="imgleft" src="tdoc.ico" width="30" height="32"  /></img>
<h2>Summary Report</h2>
		<div id="summary_report">
				<script>chk_corrupt();validate_all();point_on_first();</script>
		</div>
</div>





<script>

//------------------init js-------------------------------------------------
//alert(get_setting_count);
//Select(this);


//------------------tooltip js-------------------------------------------------

if (typeof document.attachEvent!='undefined') {
   window.attachEvent('onload',init);
   document.attachEvent('onmousemove',moveMouse);
   document.attachEvent('onclick',checkMove); }
else {
   window.addEventListener('load',init,false);
   document.addEventListener('mousemove',moveMouse,false);
   document.addEventListener('click',checkMove,false);
}

var oDv=document.createElement("div");
var dvHdr=document.createElement("div");
var dvBdy=document.createElement("div");
var windowlock,boxMove,fixposx,fixposy,lockX,lockY,fixx,fixy,ox,oy,boxLeft,boxRight,boxTop,boxBottom,evt,mouseX,mouseY,boxOpen,totalScrollTop,totalScrollLeft;
boxOpen=false;
ox=10;
oy=10;
lockX=0;
lockY=0;

function init() {
	oDv.appendChild(dvHdr);
	oDv.appendChild(dvBdy);
	oDv.style.position="absolute";
	oDv.style.visibility='hidden';
	document.body.appendChild(oDv);	
}

function defHdrStyle() {
	dvHdr.innerHTML='<img  style="vertical-align:middle"  src="info.gif">&nbsp;&nbsp;'+dvHdr.innerHTML;
	dvHdr.style.fontWeight='bold';
	dvHdr.style.width='170px';
	dvHdr.style.fontFamily='arial';
	dvHdr.style.border='1px solid #A5CFE9';
	dvHdr.style.padding='3';
	dvHdr.style.fontSize='12';
	dvHdr.style.color='#ffffff';'4B7A98';
	dvHdr.style.background='#8A0808';//D5EBF9';
	dvHdr.style.filter='alpha(opacity=100)'; // IE
	dvHdr.style.opacity='0.85'; // FF
}

function defBdyStyle() {
	dvBdy.style.borderBottom='1px solid #A5CFE9';
	dvBdy.style.borderLeft='1px solid #A5CFE9';
	dvBdy.style.borderRight='1px solid #A5CFE9';
	dvBdy.style.width='170px';
	dvBdy.style.fontFamily='arial';
	dvBdy.style.fontSize='11';
	dvBdy.style.padding='3';
	dvBdy.style.color='#ffffff';
	dvBdy.style.background='#FA58AC';
	dvBdy.style.filter='alpha(opacity=100)'; // IE
	dvBdy.style.opacity='0.85'; // FF
}

function checkElemBO(txt) {
if (!txt || typeof(txt) != 'string') return false;
if ((txt.indexOf('header')>-1)&&(txt.indexOf('body')>-1)&&(txt.indexOf('[')>-1)&&(txt.indexOf('[')>-1)) 
   return true;
else
   return false;
}

function scanBO(curNode) {
	  if (checkElemBO(curNode.title)) {
         curNode.boHDR=getParam('header',curNode.title);
         curNode.boBDY=getParam('body',curNode.title);
			curNode.boCSSBDY=getParam('cssbody',curNode.title);			
			curNode.boCSSHDR=getParam('cssheader',curNode.title);
			curNode.IEbugfix=(getParam('hideselects',curNode.title)=='on')?true:false;
			curNode.fixX=parseInt(getParam('fixedrelx',curNode.title));
			curNode.fixY=parseInt(getParam('fixedrely',curNode.title));
			curNode.absX=parseInt(getParam('fixedabsx',curNode.title));
			curNode.absY=parseInt(getParam('fixedabsy',curNode.title));
			curNode.offY=(getParam('offsety',curNode.title)!='')?parseInt(getParam('offsety',curNode.title)):10;
			curNode.offX=(getParam('offsetx',curNode.title)!='')?parseInt(getParam('offsetx',curNode.title)):10;
			curNode.fade=(getParam('fade',curNode.title)=='on')?true:false;
			curNode.fadespeed=(getParam('fadespeed',curNode.title)!='')?getParam('fadespeed',curNode.title):0.04;
			curNode.delay=(getParam('delay',curNode.title)!='')?parseInt(getParam('delay',curNode.title)):0;
			if (getParam('requireclick',curNode.title)=='on') {
				curNode.requireclick=true;
				document.all?curNode.attachEvent('onclick',showHideBox):curNode.addEventListener('click',showHideBox,false);
				document.all?curNode.attachEvent('onmouseover',hideBox):curNode.addEventListener('mouseover',hideBox,false);
			}
			else {// Note : if requireclick is on the stop clicks are ignored   			
   			if (getParam('doubleclickstop',curNode.title)!='off') {
   				document.all?curNode.attachEvent('ondblclick',pauseBox):curNode.addEventListener('dblclick',pauseBox,false);
   			}	
   			if (getParam('singleclickstop',curNode.title)=='on') {
   				document.all?curNode.attachEvent('onclick',pauseBox):curNode.addEventListener('click',pauseBox,false);
   			}
   		}
			curNode.windowLock=getParam('windowlock',curNode.title).toLowerCase()=='off'?false:true;
			curNode.title='';
			curNode.hasbox=1;
	   }
	   else
	      curNode.hasbox=2;   
}


function getParam(param,list) {
	var reg = new RegExp('([^a-zA-Z]' + param + '|^' + param + ')\\s*=\\s*\\[\\s*(((\\[\\[)|(\\]\\])|([^\\]\\[]))*)\\s*\\]');
	var res = reg.exec(list);
	var returnvar;
	if(res)
		return res[2].replace('[[','[').replace(']]',']');
	else
		return '';
}

function Left(elem){	
	var x=0;
	if (elem.calcLeft)
		return elem.calcLeft;
	var oElem=elem;
	while(elem){
		 if ((elem.currentStyle)&& (!isNaN(parseInt(elem.currentStyle.borderLeftWidth)))&&(x!=0))
		 	x+=parseInt(elem.currentStyle.borderLeftWidth);
		 x+=elem.offsetLeft;
		 elem=elem.offsetParent;
	  } 
	oElem.calcLeft=x;
	return x;
	}

function Top(elem){
	 var x=0;
	 if (elem.calcTop)
	 	return elem.calcTop;
	 var oElem=elem;
	 while(elem){		
	 	 if ((elem.currentStyle)&& (!isNaN(parseInt(elem.currentStyle.borderTopWidth)))&&(x!=0))
		 	x+=parseInt(elem.currentStyle.borderTopWidth); 
		 x+=elem.offsetTop;
	         elem=elem.offsetParent;
 	 } 
 	 oElem.calcTop=x;
 	 return x;
 	 
}

var ah,ab;
function applyStyles() {
	if(ab)
		oDv.removeChild(dvBdy);
	if (ah)
		oDv.removeChild(dvHdr);
	dvHdr=document.createElement("div");
	dvBdy=document.createElement("div");
	CBE.boCSSBDY?dvBdy.className=CBE.boCSSBDY:defBdyStyle();
	CBE.boCSSHDR?dvHdr.className=CBE.boCSSHDR:defHdrStyle();
	dvHdr.innerHTML=CBE.boHDR;
	dvBdy.innerHTML=CBE.boBDY;
	ah=false;
	ab=false;
	if (CBE.boHDR!='') {		
		oDv.appendChild(dvHdr);
		ah=true;
	}	
	if (CBE.boBDY!=''){
		oDv.appendChild(dvBdy);
		ab=true;
	}	
}

var CSE,iterElem,LSE,CBE,LBE, totalScrollLeft, totalScrollTop, width, height ;
var ini=false;

// Customised function for inner window dimension
function SHW() {
   if (document.body && (document.body.clientWidth !=0)) {
      width=document.body.clientWidth;
      height=document.body.clientHeight;
   }
   if (document.documentElement && (document.documentElement.clientWidth!=0) && (document.body.clientWidth + 20 >= document.documentElement.clientWidth)) {
      width=document.documentElement.clientWidth;   
      height=document.documentElement.clientHeight;   
   }   
   return [width,height];
}


var ID=null;
function moveMouse(e) {
   //boxMove=true;
	e?evt=e:evt=event;
	
	CSE=evt.target?evt.target:evt.srcElement;
	
	if (!CSE.hasbox) {
	   // Note we need to scan up DOM here, some elements like TR don't get triggered as srcElement
	   iElem=CSE;
	   while ((iElem.parentNode) && (!iElem.hasbox)) {
	      scanBO(iElem);
	      iElem=iElem.parentNode;
	   }	   
	}
	
	if ((CSE!=LSE)&&(!isChild(CSE,dvHdr))&&(!isChild(CSE,dvBdy))){		
	   if (!CSE.boxItem) {
			iterElem=CSE;
			while ((iterElem.hasbox==2)&&(iterElem.parentNode))
					iterElem=iterElem.parentNode; 
			CSE.boxItem=iterElem;
			}
		iterElem=CSE.boxItem;
		if (CSE.boxItem&&(CSE.boxItem.hasbox==1))  {
			LBE=CBE;
			CBE=iterElem;
			if (CBE!=LBE) {
				applyStyles();
				if (!CBE.requireclick)
					if (CBE.fade) {
						if (ID!=null)
							clearTimeout(ID);
						ID=setTimeout("fadeIn("+CBE.fadespeed+")",CBE.delay);
					}
					else {
						if (ID!=null)
							clearTimeout(ID);
						COL=1;
						ID=setTimeout("oDv.style.visibility='visible';ID=null;",CBE.delay);						
					}
				if (CBE.IEbugfix) {hideSelects();} 
				fixposx=!isNaN(CBE.fixX)?Left(CBE)+CBE.fixX:CBE.absX;
				fixposy=!isNaN(CBE.fixY)?Top(CBE)+CBE.fixY:CBE.absY;			
				lockX=0;
				lockY=0;
				boxMove=true;
				ox=CBE.offX?CBE.offX:10;
				oy=CBE.offY?CBE.offY:10;
			}
		}
		else if (!isChild(CSE,dvHdr) && !isChild(CSE,dvBdy) && (boxMove))	{
			// The conditional here fixes flickering between tables cells.
			if ((!isChild(CBE,CSE)) || (CSE.tagName!='TABLE')) {   			
   			CBE=null;
   			if (ID!=null)
  					clearTimeout(ID);
   			fadeOut();
   			showSelects();
			}
		}
		LSE=CSE;
	}
	else if (((isChild(CSE,dvHdr) || isChild(CSE,dvBdy))&&(boxMove))) {
		totalScrollLeft=0;
		totalScrollTop=0;
		
		iterElem=CSE;
		while(iterElem) {
			if(!isNaN(parseInt(iterElem.scrollTop)))
				totalScrollTop+=parseInt(iterElem.scrollTop);
			if(!isNaN(parseInt(iterElem.scrollLeft)))
				totalScrollLeft+=parseInt(iterElem.scrollLeft);
			iterElem=iterElem.parentNode;			
		}
		if (CBE!=null) {
			boxLeft=Left(CBE)-totalScrollLeft;
			boxRight=parseInt(Left(CBE)+CBE.offsetWidth)-totalScrollLeft;
			boxTop=Top(CBE)-totalScrollTop;
			boxBottom=parseInt(Top(CBE)+CBE.offsetHeight)-totalScrollTop;
			doCheck();
		}
	}
	
	if (boxMove&&CBE) {
		// This added to alleviate bug in IE6 w.r.t DOCTYPE
		bodyScrollTop=document.documentElement&&document.documentElement.scrollTop?document.documentElement.scrollTop:document.body.scrollTop;
		bodyScrollLet=document.documentElement&&document.documentElement.scrollLeft?document.documentElement.scrollLeft:document.body.scrollLeft;
		mouseX=evt.pageX?evt.pageX-bodyScrollLet:evt.clientX-document.body.clientLeft;
		mouseY=evt.pageY?evt.pageY-bodyScrollTop:evt.clientY-document.body.clientTop;
		if ((CBE)&&(CBE.windowLock)) {
			mouseY < -oy?lockY=-mouseY-oy:lockY=0;
			mouseX < -ox?lockX=-mouseX-ox:lockX=0;
			mouseY > (SHW()[1]-oDv.offsetHeight-oy)?lockY=-mouseY+SHW()[1]-oDv.offsetHeight-oy:lockY=lockY;
			mouseX > (SHW()[0]-dvBdy.offsetWidth-ox)?lockX=-mouseX-ox+SHW()[0]-dvBdy.offsetWidth:lockX=lockX;			
		}
		oDv.style.left=((fixposx)||(fixposx==0))?fixposx:bodyScrollLet+mouseX+ox+lockX+"px";
		oDv.style.top=((fixposy)||(fixposy==0))?fixposy:bodyScrollTop+mouseY+oy+lockY+"px";		
		
	}
}

function doCheck() {	
	if (   (mouseX < boxLeft)    ||     (mouseX >boxRight)     || (mouseY < boxTop) || (mouseY > boxBottom)) {
		if (!CBE.requireclick)
			fadeOut();
		if (CBE.IEbugfix) {showSelects();}
		CBE=null;
	}
}

function pauseBox(e) {
   e?evt=e:evt=event;
	boxMove=false;
	evt.cancelBubble=true;
}

function showHideBox(e) {
	oDv.style.visibility=(oDv.style.visibility!='visible')?'visible':'hidden';
}

function hideBox(e) {
	oDv.style.visibility='hidden';
}

var COL=0;
var stopfade=false;
function fadeIn(fs) {
		ID=null;
		COL=0;
		oDv.style.visibility='visible';
		fadeIn2(fs);
}

function fadeIn2(fs) {
		COL=COL+fs;
		COL=(COL>1)?1:COL;
		oDv.style.filter='alpha(opacity='+parseInt(100*COL)+')';
		oDv.style.opacity=COL;
		if (COL<1)
		 setTimeout("fadeIn2("+fs+")",20);		
}


function fadeOut() {
	oDv.style.visibility='hidden';
	
}

function isChild(s,d) {
	while(s) {
		if (s==d) 
			return true;
		s=s.parentNode;
	}
	return false;
}

var cSrc;
function checkMove(e) {
	e?evt=e:evt=event;
	cSrc=evt.target?evt.target:evt.srcElement;
	if ((!boxMove)&&(!isChild(cSrc,oDv))) {
		fadeOut();
		if (CBE&&CBE.IEbugfix) {showSelects();}
		boxMove=true;
		CBE=null;
	}
}

function showSelects(){
   var elements = document.getElementsByTagName("select");
   for (i=0;i< elements.length;i++){
      elements[i].style.visibility='visible';
   }
}

function hideSelects(){
   var elements = document.getElementsByTagName("select");
   for (i=0;i< elements.length;i++){
   elements[i].style.visibility='hidden';
   }
}

//trim   function
function trim(stringToTrim) 
{
	return stringToTrim.replace(/^\s+|\s+$/g,"");
}
function ltrim(stringToTrim) 
{
	return stringToTrim.replace(/^\s+/,"");
}
function rtrim(stringToTrim) 
{
	return stringToTrim.replace(/\s+$/,"");
}

//IsNumeric
function IsNumeric(sText)
{
   var ValidChars = "0123456789";
   var IsNumber=true;
   var Char;

 
   for (i = 0; i < sText.length && IsNumber == true; i++) 
      { 
      Char = sText.charAt(i); 
      if (ValidChars.indexOf(Char) == -1) 
         {
         IsNumber = false;
         }
      }
   return IsNumber;  
}

// return the value of the radio button that is checked
function getCheckedValue(radioObj) {
	if(!radioObj)
		return "";
	var radioLength = radioObj.length;
	if(radioLength == undefined)
		if(radioObj.checked)
			return radioObj.value;
		else
			return "";
	for(var i = 0; i < radioLength; i++) {
		if(radioObj[i].checked) {
			return radioObj[i].value;
		}
	}
	return "";
}

// set the radio button with the given value as being checked
function setCheckedValue(radioObj, newValue) {
	if(!radioObj)
		return;
	var radioLength = radioObj.length;
	if(radioLength == undefined) {
		radioObj.checked = (radioObj.value == newValue.toString());
		return;
	}
	for(var i = 0; i < radioLength; i++) {
		radioObj[i].checked = false;
		if(radioObj[i].value == newValue.toString()) {
			radioObj[i].checked = true;
		}
	}
}



</script>

</body>
</html>
